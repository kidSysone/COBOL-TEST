概要
- [値の指定](#値の指定)
- [四則計算](#四則計算)
- [ターミナルなどでの入出力](#ターミナルなどでの入出力)
- [条件分岐](#条件分岐)
  - [IF](#if)
  - [EVALUATE](#evaluate)
- [ループ文](#ループ文)
  - [PERFORM](#perform)
- [文字列関連の基本操作](#文字列関連の基本操作)
  - [長さの計算](#長さの計算)
  - [特定インデックスから文字列を取り出す](#特定インデックスから文字列を取り出す)
  - [数値文字であるかの判断](#数値文字であるかの判断)
  - [アルファベットであるかの判断](#アルファベットであるかの判断)
  - [大文字/小文字であるかの判断](#大文字小文字であるかの判断)
  - [STRING](#string)
  - [UNSTRING、文字列の分割](#unstring文字列の分割)
    - [未使用領域、LOW-VALUES](#未使用領域low-values)
  - [INSPECT文](#inspect文)
    - [検索文字列](#検索文字列)
    - [文字列の置き換え](#文字列の置き換え)

***
## 値の指定
MOVE A TO B  

※ Bの領域がAより小さく、実際に移動させた内容も大きかった場合、  
   エラーにはならず、左側の内容のみが移動できる（範囲を超えた内容は切り捨て）
## 四則計算
* 足し算：
  * `ADD A TO B.`
  * `ADD A TO B C.`。B = A + B, C = A + Cとなる
* 引き算：
  * `SUBTRACT A FROM B.`
* 掛け算：
  * `MULTIPLY A BY B.`
* 割り算：
  * `DIVIDE A BY B GIVING C REMAINDER D.`
  * A を Bで割り、結果を C に、余りは Dに
* GIVING
  * `ADD A TO B GIVING C.`
  * 計算結果の収納先を指定する
  * この場合、A及びBの値は変動されない
* COMPUTE
  * `COMPUTE C = A + B.`
  * 直感的に計算式を書ける方法
  * 必ず収納先を指定してから計算式を書く
  * `+`、`-`、`*`、`/`、`()`なども
  * 一般的な四則演算のルールが適用される（掛け算/割り算優先）

※ 文字列で上記操作を行おうとすると下記エラーが吐かれる【error: 'A' is not a numeric value】

※ 割り算とCOMPUTE方法以外、【ADD A TO B C】のような書き方で一気に複数の変数にA値を(+/-/*)することができる

## ターミナルなどでの入出力
* 入力：ACCEPT
  * `FROM CONSOLE`: 端末やコンソール画面から直接入力
* 出力：DISPLAY
  * `UPON CONSOLE`: 端末やコンソール画面に直接表示
  * `WITH NO ADVANCING`: 今回の出力は改行しない
※ 日本語/中国語などは3バイトがいるため、データ量の指定にご注意
```
DISPLAY "数値を入力してください。>> " WITH NO ADVANCING.
ACCEPT MY-DATA FROM CONSOLE.
DISPLAY '入力内容： 'MY-DATA UPON CONSOLE.
```

## 条件分岐
### IF
* ENDまでは一文のため、ピリオドは最後にだけ付ければいい
* よく使う比較演算子
  * `=`、`NOT =`、`>`、`>=`、`<`、`<=`
  * `AND`、`OR`
  * A `IS EQUAL TO` B (A = B)
  * A `IS GREATER THAN` B (A > B)
* 強制終了：`EXIT IF`

```Cobol
IF A NOT = SPACE
  DISPLAY "YES"
ELSE 
  DISPLAY "NO"
END-IF
```
※ END IF のような書き方はないため、ELSEの中で入れ子構造で書くかEVALUATEが推奨される

### EVALUATE
* JAVAなどでのswitchと同じ概念
* ENDまでは一文のため、ピリオドは最後にだけ付ければいい
* デフォ値は`WHEN OTHER`で指定する

```Cobol
EVALUATE MY-DATA
  WHEN "A"
    DISPLAY ""
  WHEN "A"
    DISPLAY ""
  WHEN "A"
    DISPLAY ""
  WHEN OTHER
    DISPLAY "WRONG DATA!"
END-EVALUATE
```

## ループ文
### PERFORM
* ENDまでは一文のため、ピリオドは最後にだけ付ければいい
* ※※ IDX の領域に気を付けましょう ※※
  * PIC "9" で、今回のように IDX > 10との条件を指定した場合、**IDX は +1 されても永遠に2桁目に入らない**ため、タイムアウトを引き起こしてしまう可能性がある
* 強制終了：`EXIT PERFORM`
```Cobol
*>>>> 回数指定 <<<<
PERFORM 10 TIMES
  *> 処理
END-PERFORM.

*>>>> 条件指定 <<<<
MOVE 1 TO IDX.
PERFORM  UNTIL IDX > 10
  *> 処理
  DISPLAY "IDX: " IDX 
  COMPUTE IDX = IDX + 1
END-PERFORM.
*> -> 1~10　が出力される

*>>>> 条件指定、ループごとに変動 <<<<
PERFORM VARYING IDX FROM 1 BY 2 UNTIL IDX > 10
  *> 処理
  DISPLAY "IDX: " IDX 
  IF IDX = 5
    EXIT PERFORM
  END-IF
END-PERFORM.
*> -> 1~9の奇数　が出力される
```

***********************************************************************
## 文字列関連の基本操作
### 長さの計算
`LENGTH OF TMP-STR` または  
`FUNCTION LENGTH()`
* ※ もしFUNCTION TRIM(TMP-STR)をかけない場合、スペースを含めた最大の長さ（定義した領域）が帰ってくる

### 特定インデックスから文字列を取り出す
TMP-STR`(A:B)`
* インデックス A 番目から
* 文字数 B 個を取り出す

```Cobol
01 TMP-STR PIC X(10) VALUE "ABCDEFGHIJ".
DISPLAY TMP-STR(3:3).     *> "CDE" が出力される
```

### 数値文字であるかの判断
TMP-STR `IS NUMERIC`
* ※ もしFUNCTION TRIM(TMP-STR)またはサイズ指定をしなかった場合、スペースを含めた内容で判断するため、スペースでFALSEだと判断される場合がある

```Cobol
01 TMP-STR-B PIC X(10) VALUE "123".
IF FUNCTION TRIM(TMP-STR-B) IS NUMERIC        *> "OK!!"
    DISPLAY "OK!!"
ELSE 
    DISPLAY "NG!!"
END-IF.
```
### アルファベットであるかの判断
TMP-STR `IS ALPHABETIC`

### 大文字/小文字であるかの判断
TMP-STR `IS ALPHABETIC-UPPER`
TMP-STR `IS ALPHABETIC-LOWER`

### STRING
* 複数の文字列を つなげて一つの領域にまとめる

* `DELIMITED BY` は「どこまでコピーするか」を指定する
  * `SIZE` → 文字列の全長（空白を入れてる場合、カットされない）
  * `SPACE` → 最初のスペースまで
  * 文字列 → 指定文字まで
* `INTO ...` → 結果を格納する変数

* ※ 注意点：
  * 切り抜きする対象と、INTOの指定先が同じ場合、同時進行のため、思った通りに切り抜けない可能性がある
  * 上書きする内容をINTOの指定先に収納する際、上書きする内容相当の領域のみが変動するため、ゴミデータが残される可能性がある（事前にMOVE SPACES TO 指定先 で防ぐ）
  * DELIMITED BYを使わないとエラー吐かれるからSIZEで言っとけばおk
  * 文字列の切り取りをする際、文字数の指定をしてなかった場合、余白が入る可能性がある（01 TEMP PIC XXX VALUE "A"でSIZEで切り抜く場合、"A  "として扱われる）。
  * `FUNCTION TRIM()`を掛けておくのが安定

```Cobol
STRING
    source1 DELIMITED BY <delimiter1>
    source2 DELIMITED BY <delimiter2>
    ...
    INTO 収納先
END-STRING
```

### UNSTRING、文字列の分割
* 分割、SPLIT
* 指定したものを探し、分割されたものを前後で考える
* `TEMP-A` `DTLS(1)` `TEMP-B`との並び
```Cobol
UNSTRING TEMP-PART(IDX)
  DELIMITED BY FUNCTION TRIM(DTLS(1))
  INTO TEMP-A TEMP-B
END-UNSTRING
```

* データを大量に分割し収納する
* TEMP-PARTの長さを余裕を持って取っておくこと
* 余分の変数に`= ALL LOW-VALUES`でチェックできる
  * "A,B"に","で分割したところ、引き渡し先が3つ以上の場合、3個目以降はSPACESでなく、`LOW-VALUES`となる
* 古いCOBOLは、分割された内容を直接に指定する必要はある
```Cobol
UNSTRING NMADR
    DELIMITED BY ","
    INTO TEMP-PART (1)
        TEMP-PART (2)
        TEMP-PART (3)
        TEMP-PART (4)
        TEMP-PART (5)
        TEMP-PART (6)
        TEMP-PART (7)
        TEMP-PART (8)
        TEMP-PART (9)
        TEMP-PART (10)
        TEMP-PART (11)
        TEMP-PART (12)
        TEMP-PART (13)
        TEMP-PART (14)
        TEMP-PART (15)
        TEMP-PART (16)
        TEMP-PART (17)
        TEMP-PART (18)
```
* ポインターを利用した書き方も可
```Cobol
PERFORM VARYING IDX FROM 1 BY 1 UNTIL IDX > 100
  UNSTRING NMADR
      DELIMITED BY ","
      INTO TEMP-PART(IDX)
      WITH POINTER POS-PTR *> POS-PTR の位置から処理を開始、終了後に次の位置に更新
      TALLYING IN LEN                *> 今回取り出した文字数を LEN に記録
  END-UNSTRING
  IF POS-PTR > LENGTH OF NMADR       *> 文字列の終端を超えたかチェック
      EXIT PERFORM
  END-IF
END-PERFORM


*> NMADR="AAA,BBB,CCC,DDD,EEE"で、DISPLAY POS-PTR"/ "LENの出力結果：
*> 0005/ 0001
*> 0009/ 0002
*> 0013/ 0003
*> 0017/ 0004

*> POS-PTR：　次回処理時の開始インデックス
*> LEN    ：　今回取り出した文字数
```

#### 未使用領域、LOW-VALUES
* 空白（SPACES）で初期化する場合とは違い、完全に「ゼロバイト」(バイナリ扱いで「完全にゼロで埋める」)
* 変数を初期化したときや、未使用領域を扱うとき に限定される
* 発生する箇所
  * 変数の初期化で明示的に設定
  * ファイルやバッファの未使用領域
  * 配列やテーブルの初期化
  * 関数や処理による自動発生
* ァイルI/Oでレコード末尾に残ったゴミ判定にも使われる
* 画面系や通信系だと `HIGH-VALUES` も同じノリで出てくる
```Cobol
IF TP-NAME NOT = ALL LOW-VALUES
```

### INSPECT文
#### 検索文字列
INSPECT [検索対象の文字列] TALLYING  
　　　　[結果保存項目] FOR ALL [検索文字列] [位置] INITIAL [検索範囲文字列]  
* 位置: BEFORE/ AFTER/ LEADING
* `INITIAL`: 書かなくてもいいが、古い処理系や互換性を意識する場合は付けておくと安心

```Cobol
MOVE "AAA_AAAA" TO WORK-STR.
INSPECT WORK-STR TALLYING WORK-RESULT FOR ALL "A". *> 全部で7
INSPECT WORK-STR TALLYING WORK-RESULT FOR ALL "A" AFTER INITIAL "-". -> "-"以降の内容を検索するため、4
INSPECT WORK-STR TALLYING WORK-RESULT FOR ALL "A" BEFORE INITIAL "/". -> "/"がないため、全検索とみなして7
```

#### 文字列の置き換え
INSPECT [置換え対象文字列] REPLACING ALL [検索文字列] BY [置換え後文字列]
　　　　[位置] INITIAL [置換え範囲文字列]  
* 位置: BEFORE/ AFTER/ LEADING
* `INITIAL`: 書かなくてもいいが、古い処理系や互換性を意識する場合は付けておくと安心

```Cobol
MOVE "AAA_AAAA" TO WORK-STR.
INSPECT WS-TEXT REPLACING ALL "A" BY "B".     -> 全置換
INSPECT WS-TEXT REPLACING ALL "A" BY "B" AFTER INITIAL "_". -> "-"以降の内容を検索するため、AAA_BBBBとなる
INSPECT WS-TEXT REPLACING ALL "A" BY "B" BEFORE INITIAL "/". -> "/"がないため、全検索とみなしてBBB_BBBBとなる
```
