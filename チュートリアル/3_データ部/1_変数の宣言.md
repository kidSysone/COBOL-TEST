概要
* [変数の宣言](#変数の宣言)
  * [変数命名の習慣](#変数命名の習慣)
    * [マジックナンバーの回避](#マジックナンバーの回避)
  * [レベル番号](#レベル番号)
    * [レベル01～49、普通のデータ項目](#レベル0149普通のデータ項目)
    * [レベル66、RENAMES](#レベル66renames)
    * [レベル77、独立データ](#レベル77独立データ)
    * [レベル78、定数定義](#レベル78定数定義)
    * [レベル88、条件名](#レベル88条件名)
  * [VALUE vs VALUES](#value-vs-values)
    * [初期値の宣言](#初期値の宣言)
    * [レベル、88](#レベル88)
  * [OCCURS](#occurs)
    * [OCCURSの入れ子構造](#occursの入れ子構造)
***
# 変数の宣言
* 基本の書き方：
  * レベル番号 + 変数名 + PIC + 領域
  * レベル番号:　
    * 集合項目で管理
    * 番号小さいほうが親
  * 変数名: 予約語が400句くらいあるため、一般的なワードを避けることが好ましい（ハイフンや数字を付けて工夫する）
    * FILLER：匿名フィールド。該項目は「名前なし」となり、使い道は“スペース埋め”や“レイアウト調整”
```Cobol
*> FILLER について
01 CUSTOMER-REC-1.
   05 CUST-ID     PIC 9(5).
   05 FILLER      PIC X(2).   *> 余白（使わない領域）
   05 CUST-NAME   PIC X(10).
DISPLAY CUSTOMER-REC-1.
*> 00000  xxxxxxxxxx のようになる

01 CUSTOMER-REC-2.
   05 CUST-ID     PIC 9(5) VALUE 1234.
   05 FILLER      PIC X(2) VALUE '--'.   *> 余白（使わない領域）
   05 CUST-NAME   PIC X(20) VALUE 'あああ'.
DISPLAY CUSTOMER-REC-2.
*> 「01234--あああ 」の出力される
*> 親変数が違えば、子の変数名がかぶってもおｋ
*> しかし、子名の衝突は避けるのが無難（フリー形式の場合、直接に指定できなくなるため）
```

* 基本の書き方：
  * PIC: PICTUREの略称。領域を描く。変数をどういう領域で確保するのかPICで命令する
  * 領域：下記記号を使って指定する
    * 長さ3の文字列は：`X(3)`または`XXX`と書く
    * **変数でのサイズ指定はコンパイラエラーになる**
    * 日本語や中国語などは一文字につき3バイナリもいる
  * `VALUE`で、デフォ値を指定する
  * 浮動小数点COMPについて、
    * 金額や帳簿 → COMP-3 **※ 誤差が出ない**
    * 計算速度重視の整数 → COMP
    * 科学計算や浮動小数点 → COMP-1 / COMP-2
  * データ部で指定した領域を超えた場合、

| 記号                | 意味                                                        | デフォ値 |
|-------------------|-----------------------------------------------------------|------|
| `9`               | 数値                                                        | 0    |
| `Z`               | 数値<br>先頭ゼロをスペース化する編集用記号                     | スペース` `<br>例：PIC ZZ9 -> `  0`となる |
| `X`               | 文字                                                        | スペース` `  |
| `A`               | 英字                                                        | スペース` `  |
| `V`               | 仮想小数点（ピリオドが格納されていない）                        | 0    |
| `S`               | 符号付き（`+`/`-`を持つ数値）                                  | `+`  |
| `COMP` / `COMP-4` | バイナリ整数                                                  |      |
| `COMP-1`          | 単精度浮動小数点<br>C言語の`float`みたいな扱い<br>`PIC 句を付けない`           |      |
| `COMP-2`          | 倍精度浮動小数点<br>C言語の`double`みたいな扱い<br>`PIC 句を付けない`          |      |
| `COMP-3`          | パック10進数 (Packed Decimal)<br>金額・会計処理でよく使う<br>小数点桁も正確に表現できる |      |

```Cobol
*> 文字列
01 DATA-1 PIC X(3) VALUE "ああ".
*> "あ"が出力される
*> ※ 日本語や中国語は一文字につき3バイナリとみなされるため、余裕をもった上限設置がおすすめ

*> 数値
01 DATA-2 PIC S9(5)V9(2) VALUE 3.1.
*> "+00003.10"が出力される

*> 領域制限を超えた場合の処理
01 A PIC 9(3) VALUE 5.
01 B PIC 9(1) VALUE 15.
01 C PIC 9(3).
...
ADD A TO B GIVING C.
DISPLAY A.  *> 005
DISPLAY B.  *> 5
DISPLAY C.  *> 010。Bは5として計算されるため5+5との計算となる
```

## 変数命名の習慣
* `WS`、WORKING-STORAGE用
* `TEMP-XXXX`、一時的な値
* `PARM-XXX`/ `PARAM-XXXX`、パラメータや引数。CALL や JCL から受け取るパラメータ
  * JCL: Job Control Language（ジョブ制御言語）。IBM メインフレームのバッチ制御言語 
* `IDX`、主にループ用インデックス（IDX -> JDX -> KDX...）
* `EOF-FLAG`、 ファイル終端(EOF)かどうかのフラグ。
* `CTR-XXXX`/ `CNT-XXXX`、カウント用（`CTR-RECORDS`、`CNT-ERRORS`）
* `SW-XXXX`、Switch用フラグ
* `FLG-XXXX`、フラグ
* `REC-XXXX`、レコード
* `FD-XXXX`、ファイル記述
* `IN-XXXX`/ `OUT-XXXX`、入力・出力データ

```Cobol
01  WS-TEMP-NUMBER  PIC 9(4).
01  IDX             PIC 99.
01  CTR-RECORDS     PIC 99.
```

### マジックナンバーの回避
使用する意図がわからない値をそのままで使用されている時、その値のことをマジックナンバーと呼ぶ
```Cobol
IF LENGTH OF WS-TRIMMED > 35  *> このような 35 はマジックナンバーと呼ぶ
```

可読性の向上、変更の便宜を図るべく、一般的には事前の定数定義が推奨される
```Cobol
78 MAX-ADDRESS-LEN VALUE 35.

MOVE FUNCTION TRIM(ADDRESS-SPLIT(1)) TO WS-TRIMMED
IF LENGTH OF WS-TRIMMED > MAX-ADDRESS-LEN    *> 事前の定義により、これは長さが上限文字数を超えてるかどうかを判断しようとしてることがわかる
```

## レベル番号
普通の「01～49」とは別に、特殊な意味を持つレベル番号が存在する  
なお、レベル番号は2桁以内 (01〜49, 66, 77, 88) に制限されており、3桁以上を書くとコンパイルエラーとなる

### レベル01～49、普通のデータ項目
* 01 は最上位のデータ項目（レコード定義など）
* 02～49 はその下の階層
* 階層を表すために使う
* 階層を飛ばしても可（01 -> 05 -> 10など）
* 50以上で非特殊レベルの数字を指定した場合も、コンパイルエラーとなる

### レベル66、RENAMES
* RENAMES 項目 を定義するために使う
* 既に定義した連続した項目を まとめて別名で呼び出せる
```Cobol
01 EMPLOYEE-REC.
   05 EMP-NAME   PIC X(20).
   05 EMP-AGE    PIC 99.
   05 EMP-SALARY PIC 9(6).

66 EMP-INFO RENAMES EMP-NAME THRU EMP-SALARY.
*> EMP-INFO を通して、EMP-NAME ～ EMP-SALARY までを一塊として扱える
```

### レベル77、独立データ
* 独立したデータ項目を定義するのに使い、下位項目を持てない
* *古いCOBOLでは「単独の変数は77」と書く慣習があったが、最近は01で統一するケースが多い

```Cobol
77 WS-COUNT PIC 9(4) VALUE 0.
```

### レベル78、定数定義
* 変数ではなく「名前付き定数」を定義する
* VALUE 句で与えた値をプログラム全体で使える
* 実行時に値が変わることは 一切ない（イミュータブル）。
* メモリ上に領域を持たず、コンパイル時に「文字置換」されるイメージ
* 他の変数と違って、MOVE や ACCEPT は不可
* マジックナンバーの回避に利用される
* `GnuCOBOL で書く場合は 78 レベルは使えない`

```Cobol
78  MAX-SIZE     VALUE 100.
78  WELCOME-MSG  VALUE "HELLO COBOL".

01 WS-ARRAY PIC X(10) OCCURS MAX-SIZE TIMES.
DISPLAY WELCOME-MSG.
```

### レベル88、条件名
* condition name
* マジックナンバーを避けるために使用することが多い
* [VALUE/ VALUES](#レベル88)の使い方について触れる

## VALUE vs VALUES
VALUE → 単一の値をセットする初期値
VALUES → 条件名（88 レベル）で範囲や複数指定

### 初期値の宣言
データ宣言時に値を初期化する
```Cobol
01 ABC PIC 999 VALUE 123.
```

### レベル、88
→ IS-OK は WS-CODE が 1～5 のとき真になる。
→ IS-NG は WS-CODE が 9 のとき真になる。
```Cobol
01 WS-CODE PIC 9.
   88 IS-OK   VALUES 1 THRU 5.  *> → 複数の値を指定できる
   88 IS-NG   VALUE  9.         *> → 単独の値を指定できる

MOCE 3 TO WS-CODE.
IF IS-OK
    display "OK!!"
ELSE 
    display "NG!!"
END-IF.

*> WS-CODE は 1~5の数値であるかどうかを判断
*> この場合、WS-CODEは3のため、TRUEとなる
```

## OCCURS
  * 配列の宣言
  * 基本の書き方：
    * レベル番号 + 変数名 + OCCURS + 配列長さ + PIC + 領域
  * インデックスは1から、順番通りに新しい項目を入れる。※ PERFORM VARYINGとのループ中は配列外の領域を読めはするためエラー出ない
  * C言語の「配列オーバーラン」と通ずるものがある
  * **配列の長さは、変数で指定することが可能**

```Cobol
*> 一般例
01 I PIC 99 VALUE 0.
01 MY-COLORS.
  03 MY-COLOR OCCURS 3 PIC 9(10).

01 MY-ITEMS-LEN PIC 99 VALUE 3.

01 MY-ITEMS.
  03 MY-ITEM OCCURS MY-ITEMS-LEN PIC x(2). *> 長さの指定は変数から指定しても可
 
MOVE 'red' TO MY-COLOR(1).
MOVE 'blue' TO MY-COLOR(2).
MOVE 'yellow' TO MY-COLOR(3).
DISPLAY MY-COLORS.
DISPLAY MY-COLOR(2).
*> 出力結果：
*> red       blue      yellow    
*> blue      
```

```Cobol
*> 配列長さ上限を超えたループ処理においでの注意点
DATA DIVISION.
WORKING-STORAGE SECTION.
01 I PIC 99 VALUE 0.
01 MY-ITEMS-1.
  03 MY-ITEMS-1-ITEM OCCURS 3 PIC 9(10).
01 MY-ITEMS-2.
  03 MY-ITEMS-2-ITEM OCCURS 3 PIC x(2).

PROCEDURE DIVISION.
 
MOVE 9  TO MY-ITEMS-1-ITEM(1).
MOVE 10 TO MY-ITEMS-1-ITEM(2).
MOVE 11 TO MY-ITEMS-1-ITEM(3).
PERFORM VARYING I FROM 0 BY 1 UNTIL I > 7
*>    MOVE I TO MY-ITEMS-1-ITEM(I)
    DISPLAY 'I は' I ': MY-ITEMS-1の内容は 【' MY-ITEMS-1-ITEM(I) '】'
END-PERFORM.
DISPLAY '----- ----- -----'.

MOVE 9  TO MY-ITEMS-2-ITEM(1).
MOVE 10 TO MY-ITEMS-2-ITEM(2).
MOVE 11 TO MY-ITEMS-2-ITEM(3).
PERFORM VARYING I FROM 0 BY 1 UNTIL I > 7
    MOVE I TO MY-ITEMS-2-ITEM(I)
    DISPLAY 'I は' I ': MY-ITEMS-2の内容は 【' MY-ITEMS-2-ITEM(I) '】'
END-PERFORM.
DISPLAY '----- ----- -----'.

*> 出力内容：
*> I は00: MY-ITEMS-1の内容は 【】
*> I は01: MY-ITEMS-1の内容は 【0000000009】
*> I は02: MY-ITEMS-1の内容は 【0000000010】
*> I は03: MY-ITEMS-1の内容は 【0000000011】
*> I は04: MY-ITEMS-1の内容は 【04】
*> I は05: MY-ITEMS-1の内容は 【  】
*> I は06: MY-ITEMS-1の内容は 【    】
*> I は07: MY-ITEMS-1の内容は 【】
----- ----- -----
*> I は00: MY-ITEMS-2の内容は 【00】
*> I は01: MY-ITEMS-2の内容は 【01】
*> I は02: MY-ITEMS-2の内容は 【02】
*> I は03: MY-ITEMS-2の内容は 【03】
*> I は04: MY-ITEMS-2の内容は 【04】
*> I は05: MY-ITEMS-2の内容は 【05】
*> I は06: MY-ITEMS-2の内容は 【06】
*> I は07: MY-ITEMS-2の内容は 【07】
----- ----- -----

*> 注意点一覧
*> 1. 数値 を 文字配列 にMOVEしても大丈夫
*> 2. I の桁数 >= 配列の桁上限はエラーしない
*> 3. ループ読み込みする際、数値配列はゴミ値が出る（右詰め数値型特有の副作用）
*>    ※ 上記コードでの出力内容では、長さ3の配列を読み込み、04-06にゴミ値が出た
*>    数値型は「右詰め＋ゼロ埋め」 でメモリに置かれるため、
*>    範囲外アクセスすると、未定義領域のバイト列が「数字＋スペース」として解釈され、表示すると不規則に見える
*> 4. 配列添字とループ表示の挙動の罠、

```

### OCCURSの入れ子構造
* Cobolは配列の中にさらに配列を持たせる、入れ子構造での宣言が可能
* 使用する際は、親→子の順番でインデックスを括弧内に直接に指定する
* ※ 親はPICで領域を振らない

```Cobol
01 LS-LIST-REC.
  05  LS-LIST-G       OCCURS 18 TIMES.  *> この場合、親はPIC型を指定してはいけない
    10  LS-LIST-COL       PIC X(35) OCCURS 40 TIMES.
  05  LS-COUNTRY-COL       PIC X(35) OCCURS 100 TIMES.

*> 使用例
DISPLAY LS-LIST-COL(IDX JDX)   *> IDX=親のインデックス, JDX=子のインデックス
```

* 子は配列じゃない場合、親のインデックスのみを指定すればおＫ
```Cobol
01  ADDRESS-DATA.
    03 ADDRESS-COLUMNS OCCURS 1000 TIMES.
      05 ADDRESS-DTLS  PIC X(35) OCCURS 18 TIMES.
      05  ZIP          PIC X(35).

DISPLAY "ZIP: " ZIP(IDX)
```
